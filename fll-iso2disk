#!/bin/bash
# Convert a live CD iso so that it's bootable from a partition
# Copyright 2007  Red Hat, Inc.
# Jeremy Katz <katzj@redhat.com>
#
# overlay/persistence enhancements by Douglas McClendon <dmc@viros.org>
# forked siduction version by Alf Gaida <agaida@siduction.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses>

# NOTE
# extra args are appended to kernel cmdlines
# There's no md5sum checking anywhere (noverify hardcoded on)
# It is hardcoded to use "siduction" as the path
# It cuts filenames down to fit 8.3
# ext* is untested
# block device as iso support newly added (untested)
# mtools and syslinux MUST BOTH be installed for fat
# syslinux alone is sufficient for ext*

# TODO if we want it, we need a checkisomd5 function :-/
noverify=1
# TODO Should be from default/distro or similar?
LiveOS="siduction"

export PATH=/sbin:/usr/sbin:$PATH

usage() {
    echo "$0 [--overlay-size-mb [<size>]] [--noboot] [--reset-mbr] [--test] <iso path> <target device> -- [kernel_args]"
    echo "creates a bootable fromiso install, with optional persist, on an existing ext2/3 or fat partition"
    exit 1
}

cleanup() {
    [ -d "$CDMNT" ] && umount $CDMNT && rmdir $CDMNT
    [ -d "$USBMNT" ] && umount $USBMNT && rmdir $USBMNT
}

exitclean() {
    echo "Cleaning up to exit..."
    cleanup
    exit 1
}

getdisk() {
    DEV=$1

    p=$(udevinfo -q path -n $DEV)
    if [ -e /sys/$p/device ]; then
	device=$(basename /sys/$p)
    else
	device=$(basename $(readlink -f /sys/$p/../))
    fi
    if [ ! -e /sys/block/$device -o ! -e /dev/$device ]; then
	echo "Error finding block device of $DEV.  Aborting!"
	exitclean
    fi

    device="/dev/$device"
}

resetMBR() {
    getdisk $1
    if [ -f /usr/lib/syslinux/mbr.bin ]; then
	cat /usr/lib/syslinux/mbr.bin > $device
    elif [ -f /usr/share/syslinux/mbr.bin ]; then
	cat /usr/share/syslinux/mbr.bin > $device
    else
	exitclean
    fi
}

checkMBR() {
    getdisk $1

    bs=$(mktemp /tmp/bs.XXXXXX)
    dd if=$device of=$bs bs=512 count=1 2>/dev/null || exit 2

    mbrword=$(hexdump -n 2 $bs |head -n 1|awk {'print $2;'})
    rm -f $bs
    if [ "$mbrword" = "0000" ]; then
	echo "MBR appears to be blank."
	echo "Do you want to replace the MBR on this device?"
	echo "Press Enter to continue or ctrl-c to abort"
	read
	resetMBR $1
    fi

    return 0
}

checkPartActive() {
    dev=$1
    getdisk $dev

    # if we're installing to whole-disk and not a partition, then we
    # don't need to worry about being active
    if [ "$dev" = "$device" ]; then
	return
    fi

    if [ "$(/sbin/fdisk -l $device 2>/dev/null |grep $dev |awk {'print $2;'})" != "*" ]; then
	echo "Partition isn't marked bootable!"
	echo "You can mark the partition as bootable with "
	if [ "$(which parted)" ]; then
		echo "    # /sbin/parted $device"
		echo "    (parted) toggle N boot"
		echo "    (parted) quit"
	else
		echo "Assuming it is the first partition"
		echo "    # /sbin/fdisk $device"
		echo "    Command (m for help): a"
		echo "    Partition number (1-4): 1"
		echo "    Command (m for help): w"
	fi
	exitclean
    fi
}

checkFilesystem() {
    dev=$1

    USBFS=$(/sbin/blkid -p $dev | sed s/.*TYPE\=\"// | cut -d\" -f1)
    if [ "$USBFS" != "vfat" -a "$USBFS" != "msdos" -a "$USBFS" != "ext2" -a "$USBFS" != "ext3" ]; then
	echo "USB filesystem must be vfat or ext[23]"
	exitclean
    fi

}

checkSyslinuxVersion() {
    if [ ! -x /usr/bin/syslinux ]; then
	echo "You need to have syslinux installed to run this script"
	exit 1
    fi
    if [ ! -x /usr/bin/mtools ]; then
	echo "You need to have mtools installed to run this script"
	exit 1
    fi
}

# TODO check why and if anything is possible?
if [ $(id -u) != 0 ]; then
    echo "You need to be root to run this script"
    exit 1
fi

while [ $# -gt 2 -a -z "$endargsfound" ]; do
    case $1 in
	--overlay-size-mb)
	    if [ $2 -gt 0 ]; then
	        overlaysizemb=$2
	        shift
	    else
	        overlaysizemb="256"
	    fi
	    ;;
	--noverify)
	    noverify=1
	    ;;
	--reset-mbr|--resetmbr)
	    resetmbr=1
	    ;;
	--noboot)
	    noboot=1
	    ;;
	--test)
	    test=1
	    ;;
	*)
            if [ "$3" = "--" ]; then
                endargsfound=1
            else
                usage
            fi
	    ;;
    esac
    if [ -z "$endargsfound" ]; then
        shift
    fi
done

ISO=$(readlink -f "$1")
USBDEV=$(readlink -f "$2")
shift
shift

if [ "$3" = "--" ]; then
    shift
fi

if [ -z "$ISO" ] || [ ! -b "$ISO" -a ! -f "$ISO" ]; then
    echo 'No suitable iso provided'
    usage
fi

if [ -z "$USBDEV" -o ! -b "$USBDEV" ]; then
    echo 'No suitable target device provided'
    usage
fi

if [ -z "$noverify" ]; then
    # verify the image
    echo "Verifying image..."
    checkisomd5 --verbose $ISO
    if [ $? -ne 0 ]; then
	echo "Are you SURE you want to continue?"
	echo "Press Enter to continue or ctrl-c to abort"
	read
    fi
fi

# do some basic sanity checks.
checkFilesystem $USBDEV
if [ -z "$noboot" ]; then
    checkSyslinuxVersion
    checkPartActive $USBDEV
    checkMBR $USBDEV
    [ -n $resetmbr ] && resetMBR $USBDEV
fi

if [ "$USBFS" = "vfat" -a  "$overlaysizemb" -gt 2047 ]; then
	echo "Can't have an overlay greater than 2048MB on VFAT"
	exitclean
fi

# FIXME: would be better if we had better mountpoints
CDMNT=$(mktemp -d /media/cdtmp.XXXXXX)
if [ -f $ISO ]; then
	mount -o loop,ro $ISO $CDMNT || exitclean
else
	mount -o ro $ISO $CDMNT || exitclean
fi
USBMNT=$(mktemp -d /media/usbdev.XXXXXX)
mount $USBDEV $USBMNT || exitclean

trap exitclean SIGINT SIGTERM

# let's try to make sure there's enough room on the partition
check=$ISO
if [ -d $USBMNT/$LiveOS ]; then
  tbd=$(du -s -B 1M $USBMNT/$LiveOS | awk {'print $1;'})
else
  tbd=0
fi
livesize=$(du -s -B 1M $check | awk {'print $1;'})
free=$(df  -B1M $USBDEV  |tail -n 1 |awk {'print $4;'})

if [ -z "$test" -a $(($overlaysizemb + $livesize)) -gt $(($free + $tbd)) ]; then
  echo "Unable to fit live image + overlay on available space on partition"
  echo "Size of live image: $livesize"
  echo "Overlay size: $overlaysizemb"
  echo "Available space: $(($free + $tbd))"
  exitclean
fi

if [ -d $USBMNT/$LiveOS ]; then
    echo "Already set up as live image.  Deleting old in fifteen seconds..."
    sleep 15

    rm -rf $USBMNT/$LiveOS
fi

echo "Copying live image to partition"

if [ ! -d $USBMNT/$LiveOS ]; then mkdir $USBMNT/$LiveOS ; fi

cp $CDMNT/boot/vmlinuz\-*\-686 $USBMNT/$LiveOS/vmlinuz.686 || exitclean
cp $CDMNT/boot/initrd.img\-*\-686 $USBMNT/$LiveOS/initrd.686 || exitclean
ISOARCH=( 686 )

if ls $CDMNT/boot/vmlinuz\-*\-amd64 > /dev/null; then
    ISOARCH+=( x64 )
    cp $CDMNT/boot/vmlinuz\-*\-amd64 $USBMNT/$LiveOS/vmlinuz.x64 || exitclean
    cp $CDMNT/boot/initrd.img\-*\-amd64 $USBMNT/$LiveOS/initrd.x64 || exitclean
fi

if [ -z "$test" ]; then
    if [ -f $ISO ]; then
        cp $ISO $USBMNT/$LiveOS/${LiveOS}.iso || exitclean
    else
        dd if=$ISO of=$USBMNT/$LiveOS/${LiveOS}.iso || exitclean
    fi
fi

if [ ! -z "$overlaysizemb" ]; then
    PERSIST='persist'
    if [ "$USBFS" = "vfat" ]; then
	echo "Initializing persistent overlay file"
        if [ -z "$test" ]; then
            dd if=/dev/zero of=$USBMNT/$LiveOS/${LiveOS}-rw count=$overlaysizemb bs=1M || exitclean
            echo 'y' | /sbin/mkfs.ext3 $USBMNT/$LiveOS/${LiveOS}-rw || exitclean
        fi
	PERSIST='persist='$LiveOS'/'$LiveOS'-rw'
    fi
fi

echo "Creating boot config file"

cp /usr/lib/syslinux/menu.c32 $USBMNT/syslinux/
echo 'default menu.c32
prompt 0
timeout 50
menu title '$LiveOS' Live Disk Boot
' > $USBMNT/syslinux/extlinux.cfg || exitclean
for MYARCH in ${ISOARCH[@]}; do
	echo 'label '$LiveOS'
menu label '$LiveOS' '$MYARCH' with persist
' >> $USBMNT/syslinux/extlinux.cfg || exitclean
	if [ "$MYARCH" = "686" ]; then
		echo 'menu default' >> $USBMNT/syslinux/extlinux.cfg || exitclean
	fi
	echo 'text help
Boots the live '$LiveOS' system from the disk.
Sets the appropriate persist option for your disk.
Stores most changes.
endtext
kernel /'$LiveOS'/vmlinuz.'$MYARCH'
append initrd=/'$LiveOS'/initrd.'$MYARCH' boot=fll quiet vga=791 fromiso='$LiveOS'/'$LiveOS'.iso '$PERSIST' '$@'
' >> $USBMNT/syslinux/extlinux.cfg || exitclean
	if [ "$PERSIST" ]; then
	echo '
label temp
menu label '$LiveOS' '$MYARCH' without persist
text help
Boots the live '$LiveOS' system from the disk.
Does not set persist so you get a clean system.
Does not store any changes.
endtext
kernel /'$LiveOS'/vmlinuz.'$MYARCH'
append initrd=/'$LiveOS'/initrd.'$MYARCH' boot=fll quiet vga=791 fromiso='$LiveOS'/'$LiveOS'.iso '$@'
' >> $USBMNT/syslinux/extlinux.cfg || exitclean
	fi
	echo 'label standard
menu label '$LiveOS' '$MYARCH' defaults
text help
Boots the live '$LiveOS' system from the disk.
Does not use any extra options.
Does not store any changes.
endtext
kernel /'$LiveOS'/vmlinuz.'$MYARCH'
append initrd=/'$LiveOS'/initrd.'$MYARCH' boot=fll quiet vga=791 fromiso='$LiveOS'/'$LiveOS'.iso
' >> $USBMNT/syslinux/extlinux.cfg || exitclean
done

if [ -z "$noboot" ]; then
    echo "Installing boot loader"
    if [ "$USBFS" = "vfat" -o "$USBFS" = "msdos" ]; then
	# syslinux expects the config to be named syslinux.cfg
	mv $USBMNT/syslinux/extlinux.cfg $USBMNT/syslinux/syslinux.cfg
        # and has to run with the file system unmounted
        cleanup
        syslinux -d syslinux $USBDEV || exitclean
    elif [ "$USBFS" = "ext2" -o "$USBFS" = "ext3" ]; then
        # TODO does extlinux.cfg need to be in $USBMNT/$LiveOS ?
        # has to be run with the file system mounted
        extlinux -d syslinux -i $USBMNT/$LiveOS || exitclean
        cleanup
    fi
fi

echo "Partition set up as live image!"
