##
##-------------------------------------
# Needs:
# HD_CHOICE
# BOOT_WHERE (also changed here)
# TARGET_MNT_POINT
# FLL_DISTRO_NAME
# HD_FSTYPE
# BOOT_RUNNING_KERNEL
# TMPDIR
# LANG
# HD_MAP
#
# Calls:
# logit
# get_root_device
# chroot_it
# translate_linux_to_grub
# get_boot_cmdline
# getbootparam
# get_esp
# get_fat
#
# update_status
# install_grub
#
##-------------------------------------
##
install_grub()
{
    local GRUB_KOPT
    local GRUB_DEFOPTIONS
    local GRUB_VGA
    local root_partition
    local root_device
    local device
    local usb_dev
    local point
    local bootfrom
    local grubdev

    #
    # log my call
    #
    logit "installing grub"
    #

    root_partition=$(echo ${HD_CHOICE} |cut -d"'" -f2)

    root_device=$(get_root_device $root_partition)

    device=$(echo $root_device|cut -d / -f3)

    usb_dev=$(readlink -f /sys/block/${device}/device | grep "usb")

    grubdev=""

    case $BOOT_WHERE in
        mbr)
                        bootfrom=$(grub-mkdevicemap -n -m - | awk '/^\(hd0\)/{print $2}')
                        grubdev="${bootfrom}"
            ;;
        partition)
            bootfrom="${root_partition}"
            ;;
        /dev/[hsv]d[a-z])
                bootfrom="${BOOT_WHERE}"
        ;;
        *)
            bootfrom="${root_partition}"
    esac

    [ -z "$grubdev" ] && grubdev="$(ls -l /dev/disk/by-id | grep ${bootfrom##*/}$)"

    # in case of jfs/xfs force installation to mbr
    # but only if it's not already MBR
    if [ "${BOOT_WHERE}" = "partition" ]; then
        case "$HD_FSTYPE" in
        jfs|xfs) bootfrom=${root_device};;
        esac
    fi

    #
    # install grub
    #
	# is twice because sometimes the first one fails in that cases the second
	# don't fail !!!
	grub-install --recheck --no-floppy --force --root-directory=$TARGET_MNT_POINT "${bootfrom}" >&2 || \
		grub-install --recheck --no-floppy --force --root-directory=$TARGET_MNT_POINT "${bootfrom}" >&2
	chroot_it sh -c "echo \"grub-pc grub-pc/install_devices multiselect ${grubdev}\" | debconf-set-selections "

	#
	# portable efi 
	#
	# when the install is on usb and that usb has a fat partition
	# we put portable efi bootloaders in the ESP on the device
	# or the first fat partition
	if [ -n "${usb_dev}" ]; then
		get_usbefi "${root_device}"
		if [ -n "${usbefi}" ]; then
			HD_MAP="$usbefi:/boot/efi ${HD_MAP}"

			# Mount it now
			mkdir $TARGET_MNT_POINT/boot/efi
			mount ${usbefi} $TARGET_MNT_POINT/boot/efi

			# Install grub-fll-portable-efi in the chroot
			EFIAPTSOURCES=$(mktemp -d --tmpdir=${TARGET_MNT_POINT}/tmp/ liveapt.XXXXXX)
			APTGETBASE="apt-get -o Dir::Etc=${EFIAPTSOURCES##${TARGET_MNT_POINT}}"
			. /lib/init/fll
			mount -o bind $(fll_get_mnt) ${TARGET_MNT_POINT}/mnt
			echo 'deb file:///mnt/extras sid main' > ${EFIAPTSOURCES}/sources.list
			mkdir ${EFIAPTSOURCES}/preferences.d
			chroot_it ${APTGETBASE} update > /dev/null
			chroot_it ${APTGETBASE} --allow-unauthenticated --assume-yes install grub2-fll-portable-efi > /dev/null
			chroot_it ${APTGETBASE} --allow-unauthenticated --assume-yes remove --purge os-prober > /dev/null || :
			umount ${TARGET_MNT_POINT}/mnt
			echo '' > ${EFIAPTSOURCES}/sources.list
			chroot_it ${APTGETBASE} update > /dev/null
			chroot_it ${APTGETBASE} clean > /dev/null
			rm -rf ${EFIAPTSOURCES}
		fi
	fi

    #
    # Create initital grub configuration (grub2 ignores -y)
    #
    say "create initial grub configuration"

    if [ -e "${TARGET_MNT_POINT}/etc/default/grub" ]; then
        #TODO a proper configuration
        # propagate the default video mode
        # extract vga mode from CMDLINE
        GRUB_DEFOPTIONS=""
        GRUB_VGA=$(getbootparam vga)
        [ -n "$GRUB_VGA" ] && GRUB_DEFOPTIONS="vga=$GRUB_VGA"

        # find out what cryptopts we need for /
        cryptopts=""
        rooton=""
        vg=$(lvs --noheadings -o vg_name $root_device 2>/dev/null | xargs echo)
        if [ -n "$vg" ]; then
            # / is in a lvm volume group
            pv=$(vgs --noheadings -o pv_name $vg  2>/dev/null | xargs echo)
            for p in $pv ; do
                # p is a physical volume in vg needed for /
                # get it's /dev/mapper name
                dmname=$(dmsetup --columns --noheadings -o name info $p  2>/dev/null | xargs echo)
                if [ -n "$dmname" ]; then
                    rooton="$rooton $dmname"
                fi
            done
        else
            # check any /dev/mapper device
            [ "${root_device}" = "${root_device##/dev/mapper/}" ] || rooton="${root_device##/dev/mapper/}"
        fi
        # if we found any mapper devices to check for crypt
        for dev in $rooton ; do
            cryptsource=$(cryptsetup status $dev 2>/dev/null | awk -F: '/device:/{print $2}' | xargs echo)
            if [ -n "$cryptsource" ] ; then
                if [ "${cryptsource}" = "${cryptsource#/dev/mapper/}" ]; then
                    # use uuid if possible for non /dev/mapper devices
                    cryptuuid=$(udevadm info -q env --name ${cryptsource} | \
                    awk 'BEGIN{FS="="}/ID_FS_UUID=/{print $2}')
                    if [ -n "${cryptuuid}" ]; then
                        cryptsource="UUID=${cryptuuid}"
                    fi
                fi
                # $dev is a crypted device on $cryptsource
                if [ -z "$GRUB_DEFOPTIONS" ]; then
                    GRUB_DEFOPTIONS="cryptopts=source=$cryptsource,target=$dev"
                else
                    GRUB_DEFOPTIONS="${GRUB_DEFOPTIONS} cryptopts=source=$cryptsource,target=$dev"
                fi
                # root is in a volume group so scan it
                [ -n "$vg" ] && GRUB_DEFOPTIONS="${GRUB_DEFOPTIONS},lvm=${root_device##/dev/mapper/}"
                echo "$dev	$cryptsource	none	luks" >> /etc/crypttab
            fi
        done
        sed -i -e "s#\(GRUB_CMDLINE_LINUX=\).*#\1\"${GRUB_DEFOPTIONS}\"#"  \
        ${TARGET_MNT_POINT}/etc/default/grub
    fi

    # update the grub config with our changes
    chroot_it update-grub >&2

    return 0
}
